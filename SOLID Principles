Problems in application which should be considered
  1>Maintainability
  2>Readebility
  3>Bugs

To tackle this SOLID principles were introduced

SOLID Principles:-

S(Single Responsibility Principle)
O(Open Close Principle)
L(Liskov Substitution Principle)
I(Interface Segrigation Principle)
D(Dependency Inversion Principle)

SRP->Every Java Class must perform single functionality, Implementation of multiple functionalities in a single class mashup the code.
  A class should have only one reason to change —
  it should do one job and do it well.

  Bad Example (Violating SRP)
  Let’s say you have a Spring Boot service that does too many things:

  @Service
  public class UserService {
  
      public void registerUser(String username, String email) {
          saveUser(username);
          sendWelcomeEmail(email);
          logRegistration(username);
      }
  
      // 1 Business logic
      private void saveUser(String username) {
          System.out.println("Saving user: " + username);
      }
  
      // 2 Email responsibility
      private void sendWelcomeEmail(String email) {
          System.out.println("Sending welcome email to " + email);
      }
  
      // 3 Logging responsibility
      private void logRegistration(String username) {
          System.out.println("Logging registration event for " + username);
      }
  }
  the class still has:
  Responsibility for user management
  Responsibility for email notifications
  Responsibility for logging
  
  So the class would need to change if:
  The email system changes (e.g., switch from SMTP to AWS SES)
  The logging mechanism changes (e.g., switch from System.out to database logging)
  The registration rules change (e.g., adding password validation)
  
  That means multiple reasons to change, which breaks SRP.

  Good Example (Following SRP)
  We’ll split the responsibilities into separate, focused classes.

  UserService — Manages user registration logic only
  @Service
  public class UserService {

    private final EmailService emailService;
    private final AuditService auditService;

    public UserService(EmailService emailService, AuditService auditService) {
        this.emailService = emailService;
        this.auditService = auditService;
    }

    public void registerUser(String username, String email) {
        // Core responsibility: user registration logic
        System.out.println("Saving user: " + username);

        // Delegating responsibilities
        emailService.sendWelcomeEmail(email);
        auditService.logRegistration(username);
      }
  }
  EmailService — Handles sending emails only
  @Service
  public class EmailService {
      public void sendWelcomeEmail(String email) {
          System.out.println("Sending welcome email to " + email);
      }
  }


OCP->A class should be open for extension but should be closed for modification
  Bad Example (Violating OCP)
  Suppose you have a service that sends notifications to users:
  
  @Service
  public class NotificationService {
  
      public void sendNotification(String message, String type) {
          if (type.equalsIgnoreCase("EMAIL")) {
              System.out.println("Sending email: " + message);
          } else if (type.equalsIgnoreCase("SMS")) {
              System.out.println("Sending SMS: " + message);
          }
      }
  }
  If tomorrow you want to support Push Notifications or WhatsApp,
  you have to edit this class — breaking the OCP.

  Good Example (Following OCP)
  We’ll refactor this using interfaces and Spring beans.

  Step 1: Create a common interface
  public interface NotificationSender {
      void send(String message);
  }
  Step 2: Create separate implementations

  public class EmailNotificationSender implements NotificationSender {
        @Override
        public void send(String message) {
            System.out.println("Sending Email: " + message);
        }
    }

  public class SmsNotificationSender implements NotificationSender {
      @Override
      public void send(String message) {
          System.out.println("Sending SMS: " + message);
      }
  }
  
  Step-3 Extend without modifying
  If you want to add a new type of notification (like Push):
  @Component("pushNotification")
  public class PushNotificationSender implements NotificationSender {
      @Override
      public void send(String message) {
          System.out.println("Sending Push Notification: " + message);
      }
  }

LSP->We have to understand this with example

  public abstract class SocialMedia {
  
      //@support WhatsApp, Facebook, Instagram
      public abstract void chatWithFriend();
  
      //@support Facebook, Instagram
      public abstract void publishPost(Object post);
  
      //@support WhatsApp, Facebook, Instagram
      public abstract void sendPhotosAndVideos();
  
      //@support WhatsApp, Facebook
      public abstract void groupVideoCall(String... users);
  }

now if we make a class instagram and then inherit Social Media Class, since all the functions of SocialMedia class are not supported by instagram like groupVideoCall,
we have to keep it, inspite no use.
to avoid this and keep or code clean and efficient 
we can make different interfaces  having different functionality and the inherit multiple class as per the need

public interface SocialMedia {

    public void chatWithFriend();

    public void sendPhotosAndVideos();
}

public interface PostMediaManager {

    public void publishPost(Object post);
}

public interface PostMediaManager{
  
    public void groupVideoCall(String... users);
}

now we can make instagram class inheriting what is needed

public class Instagram implements SocialMedia, PostMediaManager {

    public void publishPost(Object post) {
    }

    public void chatWithFriend() {
    }

    public void sendPhotosAndVideos() {
    }
}

ISP->The principle states that the larger interfaces split into smaller ones. Because the implementation classes use only the methords that are required.
We should not force the client to use methords they do not want to use.
The goal of ISP is similar to SRP.

DIP-we must use abstraction instead of concrete implementations. High level modules should not depend on low level modules but should depend on the abstraction.



